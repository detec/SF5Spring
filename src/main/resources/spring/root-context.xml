<?xml version="1.0" encoding="UTF-8"?>
<!--
    Repository and Service layers
-->
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p" 
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx" 
	xmlns:jpa="http://www.springframework.org/schema/data/jpa"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
		http://www.springframework.org/schema/security 
 		http://www.springframework.org/schema/security/spring-security-4.0.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
 
 <!-- ========================= RESOURCE DEFINITIONS ========================= -->
    
 <!-- This is for annotations to work -->	
<context:annotation-config />

<!-- This section enables autowiring -->	
<context:component-scan base-package="org.openbox.sf5.model" />
<context:component-scan base-package="org.openbox.sf5.dao" /> <!-- Probably this is for autowiring -->
<context:component-scan base-package="org.openbox.sf5.service" />
<context:component-scan base-package="org.openbox.sf5.common" />
<context:component-scan base-package="org.openbox.sf5.json.service" />

<!-- Configurer that replaces ${...} placeholders with values from a properties file -->
<!-- (in this case, JDBC-related settings for the JPA EntityManager definition below) -->
<!-- <context:property-placeholder location="classpath:data-access.properties" system-properties-mode="OVERRIDE"/> -->

<!-- application.properties are for Eclipse - file contains dev properties -->
<context:property-placeholder location="classpath:application.properties"   system-properties-mode="OVERRIDE"/>
<tx:annotation-driven transaction-manager="transactionManager"/>

	
<bean id="dataSource"
	class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="org.h2.Driver" />
	<property name="url" value="${db.jdbcUrl}" />
	<property name="username" value="sa" />
	<property name="password" value="" />
</bean>
	

	
<bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
    <property name="dataSource" ref="dataSource" />
    <property name="packagesToScan" value="org.openbox.sf5.model" />   
    <property name="configLocation"> 
		<value>classpath:hibernate.cfg.xml</value> 
    </property> 
</bean>

<bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"> 
	<property name="sessionFactory" ref="sessionFactory"/> 
</bean> 

	
<bean id="adminCheck" class="org.openbox.sf5.service.AdminCheck" init-method="initialize"></bean>

<!-- http://stackoverflow.com/questions/12123516/getting-exception-no-bean-named-springsecurityfilterchain-is-defined -->
<!-- <bean id="springSecurityFilterChain" class="org.springframework.web.filter.DelegatingFilterProxy"/> -->
 

<bean id="digestFilter" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationFilter">
<property name="userDetailsService" ref="JDBCUserService"/>
<property name="authenticationEntryPoint" ref="digestEntryPoint"/>
<!-- <property name="userCache" ref="userCache"/> -->
</bean>

<bean id="digestEntryPoint" class=
	"org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint">
<property name="realmName" value="Contacts Realm via Digest Authentication"/>
<property name="key" value="acegi"/>
<property name="nonceValiditySeconds" value="60"/>
</bean>

<bean id="expressionHandler" class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"/>

<!-- http://docs.spring.io/spring-security/site/docs/4.0.3.RELEASE/reference/htmlsingle/#el-access -->

<!-- Global Security Settings  To use expressions like @PreAuthorize-->
<!-- http://stackoverflow.com/questions/32552528/spring-security-4-preauthorizehasrole-not-working -->
<security:global-method-security pre-post-annotations="enabled" >
	 <security:expression-handler ref="expressionHandler"/>
</security:global-method-security>
	 
 
<!-- auto-config 
Automatically registers a login form, BASIC authentication, logout services. If set to "true", all of these capabilities are added 
(although you can still customize the configuration of each by providing the respective element). If unspecified, defaults to "false". Use of this attribute 
is not recommended. Use explicit configuration elements instead to avoid confusion. -->  
 
<!-- 
disable-url-rewriting  
 Prevents session IDs from being appended to URLs in the application. Clients must use cookies if this attribute is set to true. The default is true.  -->
 
<!-- entry-point-ref 
Normally the AuthenticationEntryPoint used will be set depending on which authentication mechanisms have been configured. This attribute allows this behaviour 
to be overridden by defining a customized AuthenticationEntryPoint bean which will start the authentication process. -->

<!-- name 
A bean identifier, used for referring to the bean elsewhere in the context. -->  

<!-- use-expressions 
Enables EL-expressions in the access attribute, as described in the chapter on expression-based access-control. The default value is true. -->

<!-- pattern 
Defining a pattern for the http element controls the requests which will be filtered through the list of filters which it defines. 
The interpretation is dependent on the configured request-matcher. If no pattern is defined, all requests will be matched, so the most specific patterns should be declared first.  -->

<!-- request-matcher 
Defines the RequestMatcher strategy used in the FilterChainProxy and the beans created by the intercept-url to match incoming requests. 
Options are currently ant, regex and ciRegex, for ant, regular-expression and case-insensitive regular-expression repsectively. 
A separate instance is created for each intercept-url element using its pattern and method attributes. Ant paths are matched using an AntPathRequestMatcher 
and regular expressions are matched using a RegexRequestMatcher. See the Javadoc for these classes for more details on exactly how the matching is preformed. 
Ant paths are the default strategy.    -->

<!-- <security:debug/> -->

    <!-- REST security -->
    <security:http entry-point-ref="digestEntryPoint" pattern="/json/usersettings/*" name="DigetsAuthentication" create-session="stateless">
    	<!-- We do not need sessions in stateless REST API -->
    	<security:csrf disabled="true"/>
    	
        <security:custom-filter ref="digestFilter" before="FORM_LOGIN_FILTER" />
    </security:http>
 
<!-- <security:http auto-config="true" use-expressions="true" disable-url-rewriting="true"> -->
<security:http name="LoginFormAuthentication">

	<security:session-management invalid-session-url="/login?time=1">
    	<security:concurrency-control max-sessions="1" expired-url="/login?time=1" />
    </security:session-management>

<!-- Let's not use intercept-url - we use annotations instead -->

	
	<security:intercept-url pattern="/login" access="isAnonymous()"/>
	<security:intercept-url pattern="/register" access="isAnonymous()"/>
	
	
 	<security:intercept-url pattern="/*" access="hasRole('ROLE_USER')" />
	
	
	
	
	<!--	Anonymous access to json endpoints. --> 
	<security:intercept-url pattern="/json/*" access="isAnonymous()"/>
	
	
	<!--  For all other requests -->
<!-- 	<security:intercept-url pattern="/*" access="isAnonymous()"/> -->
	
	<security:logout logout-url="/logout" logout-success-url="/login" delete-cookies="JSESSIONID" invalidate-session="true"/>
	
		 
	<security:form-login 
		login-page= '/login' 
		default-target-url="/"
		authentication-failure-url='/login.jsp?error=true'
		always-use-default-target='true'
 	/>
	
	<!-- enable csrf protection -->
	<security:csrf/>
</security:http>

 

 
 
<security:authentication-manager  alias="authenticationManager">
	<security:authentication-provider>
	<security:jdbc-user-service id="JDBCUserService"
		data-source-ref="dataSource"
		users-by-username-query="
			select	username, password, enabled from users	where username =?"
		authorities-by-username-query="select username, authority from usersauthorities where username =?" />
	</security:authentication-provider>
</security:authentication-manager>	
   
</beans>    